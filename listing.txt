=== .\cli.cpp ===
#include "cli.h"
#include "settings.h"

extern Settings settings;

// Helper: Read one line with echo (supports backspace)
String cliReadLineWithEcho(BluetoothSerial &serial) {
  String line = "";
  while (true) {
    while (!serial.available()) delay(10);
    char c = serial.read();
    if (c == '\r') continue;   // Ignore CR
    if (c == '\n') break;      // End of line
    if (c == 8 || c == 127) {  // Backspace or DEL
      if (line.length() > 0) {
        line.remove(line.length() - 1);
        serial.print("\b \b");  // Move cursor back, erase char, move back
      }
    } else if (isPrintable(c)) {
      line += c;
      serial.print(c);
    }
  }
  serial.println();
  return line;
}

void cliMode(BluetoothSerial &serial) {
  serial.println("\n--- CLI MODE ---");
  while (true) {
    serial.print("Enter command: (show, set param_name value, save, exit, reboot [bt, ntrip])\r\n> ");
    String cmdline = cliReadLineWithEcho(serial);
    cmdline.trim();
    if (cmdline.length() == 0) continue;

    int firstSpace = cmdline.indexOf(' ');
    String cmd = (firstSpace == -1) ? cmdline : cmdline.substring(0, firstSpace);
    cmd.trim();

    if (cmd == "show") {
      serial.printf("wifi: %s / %s\r\n", settings.ssid, settings.wifiPassword);
      serial.printf("ntrip host: %s:%u\r\n", settings.casterHost, settings.casterPort);
      serial.printf("mountpoint: %s\r\n", settings.mountpoint);
      serial.printf("user: %s\r\n", settings.ntripUser);
      serial.printf("pass: %s\r\n", settings.ntripPassword);
      serial.printf("baud: %lu\r\n", (unsigned long)settings.gnssBaud);
    } else if (cmd == "set") {
      // Syntax: set param_name value
      String remain = cmdline.substring(firstSpace + 1);
      remain.trim();
      int paramSpace = remain.indexOf(' ');
      if (paramSpace == -1) {
        serial.println("Invalid set command. Use: set param_name value");
        continue;
      }
      String par = remain.substring(0, paramSpace);
      String val = remain.substring(paramSpace + 1);
      par.trim();
      val.trim();

      if (par == "ssid") strncpy(settings.ssid, val.c_str(), sizeof(settings.ssid) - 1);
      else if (par == "wifipass") strncpy(settings.wifiPassword, val.c_str(), sizeof(settings.wifiPassword) - 1);
      else if (par == "host") strncpy(settings.casterHost, val.c_str(), sizeof(settings.casterHost) - 1);
      else if (par == "port") settings.casterPort = val.toInt();
      else if (par == "mount") strncpy(settings.mountpoint, val.c_str(), sizeof(settings.mountpoint) - 1);
      else if (par == "user") strncpy(settings.ntripUser, val.c_str(), sizeof(settings.ntripUser) - 1);
      else if (par == "pass") strncpy(settings.ntripPassword, val.c_str(), sizeof(settings.ntripPassword) - 1);
      else if (par == "baud") settings.gnssBaud = val.toInt();
      else serial.println("Unknown param");
    } else if (cmd == "save") {
      settingsSave();
      serial.println("Settings saved.");
    } else if (cmd == "exit") {
      serial.println("Exiting CLI.");
      break;
    } else if (cmd == "reboot") {
      // Syntax: reboot [mode]
      String remain = cmdline.substring(firstSpace + 1);
      remain.trim();

      uint8_t requested = 0;  // 0=use normal
      if (remain.length() == 0) {
        // No mode, just normal reboot
        requested = 0;
      } else if (remain.equalsIgnoreCase("ntrip")) {
        requested = 1;
      } else if (remain.equalsIgnoreCase("bt") || remain.equalsIgnoreCase("bluetooth")) {
        requested = 2;
      } else {
        serial.println("Unknown mode. Use: reboot [ntrip|bt]");
        continue;
      }
      if (requested) {
        settings.oneShotMode = requested;
        settingsSave();  // save override to EEPROM
        serial.printf("Rebooting to %s mode...\r\n", requested == 1 ? "NTRIP" : "Bluetooth");
      } else {
        serial.println("Rebooting...");
      }
      delay(100);
      ESP.restart();  // Reboot immediately
    }
  }
}

=== .\cli.h ===
#pragma once
#include <BluetoothSerial.h>
void cliMode(BluetoothSerial &serial);

=== .\gnss_uart.cpp ===
#include <HardwareSerial.h>
HardwareSerial GNSS(2);

=== .\gnss_uart.h ===
#pragma once
#include <HardwareSerial.h>
extern HardwareSerial GNSS;

=== .\mode_bt.cpp ===
#include "mode_bt.h"
#include <BluetoothSerial.h>
#include <HardwareSerial.h>
#include "settings.h"
#include "cli.h"
#include <WiFi.h> 
#include "gnss_uart.h"

extern Settings settings;

#define UART2_RX 16 // Set according to physical wiring
#define UART2_TX 17

#define MAGIC_SEQ "+++cli+++"

BluetoothSerial SerialBT;

bool detectMagicChar(char input, const char *magicSeq, size_t &index) {
  size_t len = strlen(magicSeq);
  if (input == magicSeq[index]) {
    index++;
    if (index == len) {
      index = 0; // Reset for retriggering
      return true;
    }
  } else {
    index = (input == magicSeq[0]) ? 1 : 0;
  }
  return false;
}

void runBluetoothTransparentMode() {
    // WiFi off for low power
    WiFi.mode(WIFI_OFF);
    btStop(); // stop classic, in case
    delay(50);
    btStart(); // start
    // Start Bluetooth
    SerialBT.begin("RFGNSSESP32");
    // Start GNSS UART
    GNSS.begin(settings.gnssBaud, SERIAL_8N1, UART2_RX, UART2_TX);

  size_t magicIndex = 0;

  for (;;) {
    if (SerialBT.available()) {
      char c = SerialBT.read();
      if (detectMagicChar(c, MAGIC_SEQ, magicIndex)) {
        cliMode(SerialBT);
        continue;
      }
      GNSS.write((uint8_t)c);
    }
    if (GNSS.available()) {
      SerialBT.write(GNSS.read());
    }
    delay(1);
  }
}

=== .\mode_bt.h ===
#pragma once

void runBluetoothTransparentMode();

=== .\mode_ntrip.cpp ===
#include "mode_ntrip.h"
#include "settings.h"
#include <WiFi.h>
#include <WiFiClient.h>
// #include "NTRIPClient.h" // Youâ€™ll need to install or copy an NTRIP server/client implementation
#include <HardwareSerial.h>
#include "gnss_uart.h"

extern Settings settings;

#define UART2_RX 16  // Set according to physical wiring
#define UART2_TX 17


#define LED_PIN 2


void blinkTask(void *pvParameters) {
  pinMode(LED_PIN, OUTPUT);
  for (;;) {
    digitalWrite(LED_PIN, HIGH);
    vTaskDelay(1000 / portTICK_PERIOD_MS);  // 1000 ms == 1s
    digitalWrite(LED_PIN, LOW);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
  // Optionally vTaskDelete(NULL);
}

void runNtripServerMode() {
  pinMode(2, OUTPUT);
  Serial.begin(115200);
  delay(100);  // Allow time for Serial to initialize

  // Start WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(settings.ssid, settings.wifiPassword);
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    if (millis() - t0 > 15000) {
      // timeout, fallback to BT for config if needed
      // blink LED or similar, or reboot
      ESP.restart();
    }
  }

  // Once WiFi is connected, print IP address to serial
  Serial.print("WiFi connected. IP address: ");
  Serial.println(WiFi.localIP());

  GNSS.begin(settings.gnssBaud, SERIAL_8N1, UART2_RX, UART2_TX);

  // NTRIPServer ntrip;
  // ntrip.begin(settings.casterHost,
  //             settings.casterPort,
  //             settings.mountpoint,
  //             settings.ntripUser,
  //             settings.ntripPassword);

  xTaskCreatePinnedToCore(
    blinkTask,    // Task code
    "BlinkTask",  // name
    2048,         // stack size (words, not bytes!)
    NULL,         // params
    1,            // priority
    NULL,         // task handle
    1);           // core (0 or 1)

  for (;;) {

   



    // Forward GNSS output to NTRIP server
    //   while (GNSS.available()) {
    //   // ntrip.send(GNSS.read());
    // }
    // ntrip.handleClient(); // allow NTRIP server to clear clients/make connections
    delay(1);
  }
}

=== .\mode_ntrip.h ===
#pragma once

void runNtripServerMode();

=== .\settings.cpp ===
#include "settings.h"
#include <EEPROM.h>

Settings settings;

#define EEPROM_SIZE 512

void settingsDefault() {
  strcpy(settings.ssid, "your_wifi");
  strcpy(settings.wifiPassword, "your_password");
  strcpy(settings.casterHost, "ntrip.caster.tld");
  settings.casterPort = 2101;
  strcpy(settings.mountpoint, "MYMOUNT");
  strcpy(settings.ntripUser, "user");
  strcpy(settings.ntripPassword, "pass");
  settings.gnssBaud = 115200;
  settings.oneShotMode = 0;
}

void settingsLoad() {
  EEPROM.begin(EEPROM_SIZE);
  if (EEPROM.read(0) != 0xAB) {
    settingsDefault();
    settingsSave();
    return;
  }
  EEPROM.get(1, settings);
}

void settingsSave() {
  EEPROM.write(0, 0xAB);
  EEPROM.put(1, settings);
  EEPROM.commit();
}

=== .\settings.h ===
#pragma once
#include <Arduino.h>

struct Settings {
  char ssid[33];
  char wifiPassword[65];
  char casterHost[40];
  uint16_t casterPort;
  char mountpoint[40];
  char ntripUser[40];
  char ntripPassword[40];
  uint32_t gnssBaud;
  uint8_t oneShotMode; // 0=none/normal, 1=ntrip, 2=bt
};

extern Settings settings;

void settingsLoad();
void settingsSave();

=== .\twoModeGNSS.ino ===
#include "mode_bt.h"
#include "mode_ntrip.h"
#include "settings.h"

#define BUTTON_PIN 0  // set according to your connection

void setup() {
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  settingsLoad();

  if (settings.oneShotMode == 1 || settings.oneShotMode == 2) {
    // Clear flag for next boot!
    uint8_t mode = settings.oneShotMode;
    settings.oneShotMode = 0;
    settingsSave();

    if (mode == 1) {
      runNtripServerMode();
    } else if (mode == 2) {
      runBluetoothTransparentMode();
    }
  }

  if (digitalRead(BUTTON_PIN) == LOW) {
    runNtripServerMode();
  } else {
    runBluetoothTransparentMode();
  }
}

void loop() {
  // Nothing, all logic inside task loops
}

